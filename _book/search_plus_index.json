{"./":{"url":"./","title":"介绍","keywords":"","body":"前言 这个比什么都没留下...................................... © luckly FED Team all right reserved，powered by Gitbook该文件修订时间： 2022-10-31 16:27:06 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/i.html":{"url":"Chapter1/i.html","title":"C语言学习","keywords":"","body":"C语言学习 © luckly FED Team all right reserved，powered by Gitbook该文件修订时间： 2022-10-31 16:59:34 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/f.html":{"url":"Chapter1/f.html","title":"基本数据类型","keywords":"","body":"基本数据类型 关键字 说明 auto 声明自动变量 break 跳出当前循环 case 开关语句分支 char 声明字符型变量或函数返回值类型 const 定义常量，如果一个变量被 const 修饰，那么它的值就不能再被改变 continue 结束当前循环，开始下一轮循环 default 开关语句中的\"其它\"分支 do 循环语句的循环体 double 声明双精度浮点型变量或函数返回值类型 else 条件语句否定分支（与 if 连用） enum 声明枚举类型 extern 声明变量或函数是在其它文件或本文件的其他位置定义 float 声明浮点型变量或函数返回值类型 for 一种循环语句 goto 无条件跳转语句 if 条件语句 int 声明整型变量或函数 long 声明长整型变量或函数返回值类型 register 声明寄存器变量 return 子程序返回语句（可以带参数，也可不带参数） short 声明短整型变量或函数 signed 声明有符号类型变量或函数 sizeof 计算数据类型或变量长度（即所占字节数） static 声明静态变量 struct 声明结构体类型 switch 用于开关语句 typedef 用以给数据类型取别名 unsigned 声明无符号类型变量或函数 union 声明共用体类型 void 声明函数无返回值或无参数，声明无类型指针 volatile 说明变量在程序执行中可被隐含地改变 while 循环语句的循环条件 数据类型 序号 类型与描述 1 基本类型： 它们是算术类型，包括两种类型：整数类型和浮点类型。 2 枚举类型： 它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。 3 void 类型： 类型说明符 void 表明没有可用的值。 4 派生类型： 它们包括：指针类型、数组类型、结构类型、共用体类型和函数类型。 整数类型 下表列出了关于标准整数类型的存储大小和值范围的细节： 类型 存储大小 值范围 char 1 字节 -128 到 127 或 0 到 255 unsigned char 1 字节 0 到 255 signed char 1 字节 -128 到 127 int 2 或 4 字节 -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 unsigned int 2 或 4 字节 0 到 65,535 或 0 到 4,294,967,295 short 2 字节 -32,768 到 32,767 unsigned short 2 字节 0 到 65,535 long 4 字节 -2,147,483,648 到 2,147,483,647 unsigned long 4 字节 0 到 4,294,967,295 注意，各种类型的存储大小与系统位数有关，但目前通用的以64位系统为主。 以下列出了32位系统与64位系统的存储大小的差别（windows 相同）： 浮点类型 下表列出了关于标准浮点类型的存储大小、值范围和精度的细节： 类型 存储大小 值范围 精度 float 4 字节 1.2E-38 到 3.4E+38 6 位有效位 double 8 字节 2.3E-308 到 1.7E+308 15 位有效位 long double 16 字节 3.4E-4932 到 1.1E+4932 19 位有效位 void 类型 void 类型指定没有可用的值。它通常用于以下三种情况下： 序号 类型与描述 1 函数返回为空 C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 void exit (int status); 2 函数参数为空 C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 int rand(void); 3 指针指向 void 类型为 void 的指针代表对象的地址，而不是类型。例如，内存分配函数 **void \\malloc( size_t size );** 返回指向 void 的指针，可以转换为任何数据类型。 C语言的数据类型转换 1、数据类型转换：C 语言中如果一个表达式中含有不同类型的常量和变量，在计算时，会将它们自动转换为同一种类型；在 C 语言中也可以对数据类型进行强制转换； 2、自动转换规则： a）浮点数赋给整型，该浮点数小数被舍去； b）整数赋给浮点型，数值不变，但是被存储到相应的浮点型变量中； 3、强制类型转换形式: (类型说明符)(表达式) #include int main() { float f,x=3.6,y=5.2; int i=4,a,b; a=x+y; b=(int)(x+y); f=10/i; printf(\"a=%d,b=%d,f=%f,x=%f\\n\",a,b,f,x); } 解析：例中先计算 x+y 值为 8.8，然后赋值给 a，因为a为整型，所以自取整数部分8，a=8; 接下来 b 把 x+y 强制转换为整型; 最后 10/i 是两个整数相除，结果仍为整数 2，把 2 赋给浮点数 f; x 为浮点型直接输出。 © luckly FED Team all right reserved，powered by Gitbook该文件修订时间： 2022-09-15 15:37:12 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/a.html":{"url":"Chapter1/a.html","title":"变量，常量，存储类","keywords":"","body":"变量 理解：变量其实只不过是程序可操作的存储区的名称。C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。 组成：变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C 是大小写敏感的。 类型 描述 char 通常是一个字节（八位）, 这是一个整数类型。 int 整型，4 个字节，取值范围 -2147483648 到 2147483647。 float 单精度浮点值。单精度是这样的格式，1位符号，8位指数，23位小数。 double 双精度浮点值。双精度是1位符号，11位指数，52位小数。 void 表示类型的缺失。 变量的定义 变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表。 type variable_list; /* 在这里，type 必须是一个有效的 C 数据类型，可以是 char、w_char、int、float、double 或任何用户自定义的对象，variable_list 可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔 */ extern int d = 3, f = 5; // d 和 f 的声明与初始化 int d = 3, f = 5; // 定义并初始化 d 和 f byte z = 22; // 定义并初始化 z char x = 'x'; // 变量 x 的值为 'x' 变量的声明 1、一种是需要建立存储空间的。例如：int a 在声明的时候就已经建立了存储空间。 2、另一种是不需要建立存储空间的，通过使用extern关键字声明变量名而不定义它。 例如：extern int a 其中变量 a 可以在别的文件中定义的。 3、除非有extern关键字，否则都是变量的定义。 extern int i; //声明，不是定义 int i; //声明，也是定义 关于变量以声明但初始化在函数内 #include // 函数外定义变量 x 和 y int x; int y; int addtwonum() { // 函数内声明变量 x 和 y 为外部变量 extern int x; extern int y; // 给外部变量（全局变量）x 和 y 赋值 x = 1; y = 2; return x+y; } int main() { int result; // 调用函数 addtwonum result = addtwonum(); printf(\"result 为: %d\",result); return 0; } //上述代码结果 result 为：3 两个源文件中对于变量的操作 //一号源文件 #include /*外部变量声明，*/ extern int x ; extern int y ; int addtwonum() { return x+y; } //二号源文件 #include /*定义两个全局变量，此处的x，y为一号源文件的x，y一号源文件中只声明了x，y，二号源文件中的x，y为定义，这符合之前所说的（另一种是不需要建立存储空间的，通过使用extern关键字声明变量名而不定义它。 例如：extern int a 其中变量 a 可以在别的文件中定义的）有点像之前声明了它，只是在二号中调用一样*/ int x=1; int y=2; int addtwonum(); int main(void) { int result; result = addtwonum(); printf(\"result 为: %d\\n\",result); return 0; } 最后输出结果为：result 为: 3 C 中的左值（Lvalues）和右值（Rvalues） C 中有两种类型的表达式： 左值（lvalue）：指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。 右值（rvalue）：术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。 注：变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边 // 正确实列 int g = 20; //下面这个无法编译有问题 10 = 20; 常量 常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做字面量。 常量可以是任何的基本数据类型，比如整数常量、浮点常量、字符常量，或字符串字面值，也有枚举常量。 常量就像是常规的变量，只不过常量的值在定义后不能进行修改。 整数常量 整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。 整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。 212 /* 合法的 */ 215u /* 合法的 */ 0xFeeL /* 合法的 */ 078 /* 非法的：8 不是八进制的数字 */ 032UU /* 非法的：不能重复后缀 */ 85 /* 十进制 */ 0213 /* 八进制 */ 0x4b /* 十六进制 */ 30 /* 整数 */ 30u /* 无符号整数 */ 30l /* 长整数 */ 30ul /* 无符号长整数 */ 浮点常量 浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。 当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。 3.14159 /* 合法的 */ 314159E-5L /* 合法的 */ 510E /* 非法的：不完整的指数 */ 210f /* 非法的：没有小数或指数 */ .e55 /* 非法的：缺少整数或分数 */ 字符常量 字符常量是括在单引号中，例如，'x' 可以存储在 char 类型的简单变量中。 字符常量可以是一个普通的字符（例如 'x'）、一个转义序列（例如 '\\t'），或一个通用的字符（例如 '\\u02C0'）。 在 C 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\\n）或制表符（\\t）等。下表列出了一些这样的转义序列码： 转义序列 含义 \\ \\ 字符 \\' ' 字符 \\\" \" 字符 \\? ? 字符 \\a 警报铃声 \\b 退格键 \\f 换页符 \\n 换行符 \\r 回车 \\t 水平制表符 \\v 垂直制表符 \\ooo 一到三位的八进制数 \\xhh . . . 一个或多个数字的十六进制数 #include int main() { printf(\"Hello\\tWorld\\n\\n\"); return 0; } //结果为Hello World 字符串常量 字符串字面值或常量是括在双引号 \"\" 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。 您可以使用空格做分隔符，把一个很长的字符串常量进行分行。 下面这三种形式所显示的字符串是相同的。 \"hello, dear\" \"hello, \\ dear\" \"hello, \" \"d\" \"ear\" 定义常量 在 C 中，有两种简单的定义常量的方式： 使用 #define 预处理器。 使用 const 关键字。 #define 预处理器 #include //#define identifier value 使用define定义常量的形式 #define LENGTH 10 #define WIDTH 5 #define NEWLINE '\\n' int main() { int area; area = LENGTH * WIDTH; printf(\"value of area : %d\", area); printf(\"%c\", NEWLINE); return 0; } //上述代码运行结果为 value of area : 50 注：格式说明由“％”和格式字符组成，如％d％f等。它的作用是将输出的数据转换为指定的格式输出。格式说明总是由“％”字符开始的。不同类型的数据用不同的格式字符。 格式字符有d,o,x,u,c,s,f,e,g等。 如 ％d整型输出，％ld长整型输出， ％o以八进制数形式输出整数， ％x以十六进制数形式输出整数， ％u以十进制数输出unsigned型数据(无符号数)。 ％c用来输出一个字符， ％s用来输出一个字符串， ％f用来输出实数，以小数形式输出，（备注：浮点数是不能定义如的精度的，所以“%6.2f”这种写法是“错误的”！！！） ％e以指数形式输出实数， ％g根据大小自动选f格式或e格式，且不输出无意义的零。 scanf(控制字符，地址列表) 格式字符的含义同printf函数，地址列表是由若干个地址组成的表列，可以是变量的地址，或字符串的首地址。如scanf(\"％d％c％s\",&a,&b,str)； const 关键字 #include //const type variable = value; 用const定义常量的形式，const 声明常量要在一个语句内完成： int main() { const int LENGTH = 10; const int WIDTH = 5; const char NEWLINE = '\\n'; int area; area = LENGTH * WIDTH; printf(\"value of area : %d\", area); printf(\"%c\", NEWLINE); return 0; } //运行结果为 value of area : 50 C 存储类 存储类定义 C 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C 程序中可用的存储类： auto register static extern auto 存储类 auto 存储类是所有局部变量默认的存储类。 { int mount; auto int month; } //上面的实例定义了两个带有相同存储类的变量，auto 只能用在函数内，即 auto 只能修饰局部变量 register 存储类 register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个字），且不能对它应用一元的 '&' 运算符（因为它没有内存位置）。 { register int miles; } //寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 'register' 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。 static 存储类 static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。 static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。 全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中。 #include // static 修饰全局变量和局部变量,count 作为全局变量可以在函数内使用，thingy 使用 static 修饰后，不会在每次调用时重置 /* 函数声明 */ void func1(void); static int count=10; /* 全局变量 - static 是默认的 */ int main() { while (count--) { func1(); } return 0; } void func1(void) { /* 'thingy' 是 'func1' 的局部变量 - 只初始化一次 * 每次调用函数 'func1' 'thingy' 值不会被重置。 */ static int thingy=5; thingy++; printf(\" thingy 为 %d ， count 为 %d\\n\", thingy, count); } //运行结果为： /* thingy 为 6 ， count 为 9 thingy 为 7 ， count 为 8 thingy 为 8 ， count 为 7 thingy 为 9 ， count 为 6 thingy 为 10 ， count 为 5 thingy 为 11 ， count 为 4 thingy 为 12 ， count 为 3 thingy 为 13 ， count 为 2 thingy 为 14 ， count 为 1 thingy 为 15 ， count 为 0 */ extern 存储类(此处可以参考上面变量声明部分中两个源文件中对于变量的操作) extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 extern 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。 当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。 #include //一号源文件 int count ; extern void write_extern(); int main() { count = 5; write_extern(); } //运行结果为：count is 5 #include //二号源文件 extern int count; void write_extern(void) { printf(\"count is %d\\n\", count); } 超链接显示名 © luckly FED Team all right reserved，powered by Gitbook该文件修订时间： 2022-11-23 11:07:30 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/h.html":{"url":"Chapter1/h.html","title":"C语言中的作用域规则","keywords":"","body":"C 作用域规则 C 语言中有三个地方可以声明变量： 在函数或块内部的局部变量 在所有函数外部的全局变量 在形式参数的函数参数定义中 局部变量 在某个函数或块的内部声明的变量称为局部变量。它们只能被该函数或该代码块内部的语句使用。局部变量在函数外部是不可知的，代码中所有的变量 a、b 和 c 是 main() 函数的局部变量。 #include int main () { /* 局部变量声明 */ int a, b; int c; /* 实际初始化 */ a = 10; b = 20; c = a + b; printf (\"value of a = %d, b = %d and c = %d\\n\", a, b, c); return 0; } 全局变量 全局变量是定义在函数外部，通常是在程序的顶部。全局变量在整个程序生命周期内都是有效的，在任意的函数内部能访问全局变量。 全局变量可以被任何函数访问。也就是说，全局变量在声明后整个程序中都是可用的 #include /* 全局变量声明 */ int g; int main () { /* 局部变量声明 */ int a, b; /* 实际初始化 */ a = 10; b = 20; g = a + b; printf (\"value of a = %d, b = %d and g = %d\\n\", a, b, g); return 0; } // 注：在程序中，局部变量和全局变量的名称可以相同，但是在函数内，如果两个名字相同，会使用局部变量值，全局变量不会被使用(参考代码) #include /* 全局变量声明 */ int g = 20; int main () { /* 局部变量声明 */ int g = 10; printf (\"value of g = %d\\n\", g); return 0; } //代码运行结果为：value of g = 10 全局变量与局部变量在内存中的区别： 全局变量保存在内存的全局存储区中，占用静态的存储单元； 局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。初始化局部变量和全局变量 初始化局部变量和全局变量 当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动对其初始化，如下所示： 数据类型 初始化默认值 int 0 char '\\0' float 0 double 0 pointer NULL 形式参数 函数的参数，形式参数，被当作该函数内的局部变量，如果与全局变量同名它们会优先使用 #include /* 全局变量声明 */ int a = 20; int main () { /* 在主函数中的局部变量声明 */ int a = 10; int b = 20; int c = 0; int sum(int, int); printf (\"value of a in main() = %d\\n\", a); c = sum( a, b); printf (\"value of c in main() = %d\\n\", c); return 0; } /* 添加两个整数的函数 */ int sum(int a, int b) { printf (\"value of a in sum() = %d\\n\", a); printf (\"value of b in sum() = %d\\n\", b); return a + b; } //运行结果为: /* value of a in main() = 10 value of a in sum() = 10 value of b in sum() = 20 value of c in main() = 30 */ © luckly FED Team all right reserved，powered by Gitbook该文件修订时间： 2022-09-16 11:16:24 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/e.html":{"url":"Chapter1/e.html","title":"运算符，判断，循环","keywords":"","body":"C 运算符 运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C 语言内置了丰富的运算符，并提供了以下类型的运算符： 算术运算符 关系运算符 逻辑运算符 位运算符 赋值运算符 杂项运算符 算术运算符 下表显示了 C 语言支持的所有算术运算符。假设变量 A 的值为 10，变量 B 的值为 20，则： 运算符 描述 实例 + 把两个操作数相加 A + B 将得到 30 - 从第一个操作数中减去第二个操作数 A - B 将得到 -10 * 把两个操作数相乘 A * B 将得到 200 / 分子除以分母 B / A 将得到 2 % 取模运算符，整除后的余数 B % A 将得到 0 ++ 自增运算符，整数值增加 1 A++ 将得到 11 -- 自减运算符，整数值减少 1 A-- 将得到 9 #include int main() { int a = 21; int b = 10; int c ; c = a + b; printf(\"Line 1 - c 的值是 %d\\n\", c ); c = a - b; printf(\"Line 2 - c 的值是 %d\\n\", c ); c = a * b; printf(\"Line 3 - c 的值是 %d\\n\", c ); c = a / b; printf(\"Line 4 - c 的值是 %d\\n\", c ); c = a % b; printf(\"Line 5 - c 的值是 %d\\n\", c ); c = a++; // 赋值后再加 1 ，c 为 21，a 为 22 printf(\"Line 6 - c 的值是 %d\\n\", c ); c = a--; // 赋值后再减 1 ，c 为 22 ，a 为 21 printf(\"Line 7 - c 的值是 %d\\n\", c ); } /*运行结果为： Line 1 - c 的值是 31 Line 2 - c 的值是 11 Line 3 - c 的值是 210 Line 4 - c 的值是 2 Line 5 - c 的值是 1 Line 6 - c 的值是 21 Line 7 - c 的值是 22 */ #include // a++ 与 ++a 的区别 int main() { int c; int a = 10; c = a++; printf(\"先赋值后运算：\\n\"); printf(\"Line 1 - c 的值是 %d\\n\", c ); printf(\"Line 2 - a 的值是 %d\\n\", a ); a = 10; c = a--; printf(\"Line 3 - c 的值是 %d\\n\", c ); printf(\"Line 4 - a 的值是 %d\\n\", a ); printf(\"先运算后赋值：\\n\"); a = 10; c = ++a; printf(\"Line 5 - c 的值是 %d\\n\", c ); printf(\"Line 6 - a 的值是 %d\\n\", a ); a = 10; c = --a; printf(\"Line 7 - c 的值是 %d\\n\", c ); printf(\"Line 8 - a 的值是 %d\\n\", a ); } /*运行结果为： 先赋值后运算： Line 1 - c 的值是 10 Line 2 - a 的值是 11 Line 3 - c 的值是 10 Line 4 - a 的值是 9 先运算后赋值： Line 5 - c 的值是 11 Line 6 - a 的值是 11 Line 7 - c 的值是 9 Line 8 - a 的值是 9 */ 关系运算符(与C#无异) 下表显示了 C 语言支持的所有关系运算符。假设变量 A 的值为 10，变量 B 的值为 20，则： 运算符 描述 实例 == 检查两个操作数的值是否相等，如果相等则条件为真。 (A == B) 为假。 != 检查两个操作数的值是否相等，如果不相等则条件为真。 (A != B) 为真。 > 检查左操作数的值是否大于右操作数的值，如果是则条件为真。 (A > B) 为假。 检查左操作数的值是否小于右操作数的值，如果是则条件为真。 (A >= 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 (A >= B) 为假。 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 (A #include int main() { int a = 21; int b = 10; int c ; if( a == b ) { printf(\"Line 1 - a 等于 b\\n\" ); } else { printf(\"Line 1 - a 不等于 b\\n\" ); } if ( a b ) { printf(\"Line 3 - a 大于 b\\n\" ); } else { printf(\"Line 3 - a 不大于 b\\n\" ); } /* 改变 a 和 b 的值 */ a = 5; b = 20; if ( a = a ) { printf(\"Line 5 - b 大于或等于 a\\n\" ); } } /*运行结果为 Line 1 - a 不等于 b Line 2 - a 不小于 b Line 3 - a 大于 b Line 4 - a 小于或等于 b Line 5 - b 大于或等于 a */ 逻辑运算符 下表显示了 C 语言支持的所有关系逻辑运算符。假设变量 A 的值为 1，变量 B 的值为 0，则： 运算符 描述 实例 && 称为逻辑与运算符。如果两个操作数都非零，则条件为真。 (A && B) 为假。 \\ \\ 称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。 (A \\ \\ B) 为真。 ! 称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。 !(A && B) 为真。 #include int main() { int a = 5; int b = 20; int c ; if ( a && b ) { printf(\"Line 1 - 条件为真\\n\" ); } if ( a || b ) { printf(\"Line 2 - 条件为真\\n\" ); } /* 改变 a 和 b 的值 */ a = 0; b = 10; if ( a && b ) { printf(\"Line 3 - 条件为真\\n\" ); } else { printf(\"Line 3 - 条件为假\\n\" ); } if ( !(a && b) ) { printf(\"Line 4 - 条件为真\\n\" ); } } /*运行结果 Line 1 - 条件为真 Line 2 - 条件为真 Line 3 - 条件为假 Line 4 - 条件为真 */ 位运算符 位运算符作用于位，并逐位执行操作。&、 | 和 ^ 的真值表如下所示： p q p & q p \\ q p ^ q 0 0 0 0 0 0 1 0 1 1 1 1 1 1 0 1 0 0 1 1 假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示： A = 0011 1100 B = 0000 1101 ----------------- A&B = 0000 1100 A|B = 0011 1101 A^B = 0011 0001 ~A = 1100 0011 下表显示了 C 语言支持的位运算符。假设变量 A 的值为 60，变量 B 的值为 13，则： 运算符 描述 实例 & 按位与操作，按二进制位进行\"与\"运算。运算规则：0&0=0; 0&1=0; 1&0=0; 1&1=1; (A & B) 将得到 12，即为 0000 1100 \\ 按位或运算符，按二进制位进行\"或\"运算。运算规则：`0 0=0; 0 1=1; 1 0=1; 1 1=1;` (A \\ B) 将得到 61，即为 0011 1101 ^ 异或运算符，按二进制位进行\"异或\"运算。运算规则：0^0=0; 0^1=1; 1^0=1; 1^1=0; (A ^ B) 将得到 49，即为 0011 0001 ~ 取反运算符，按二进制位进行\"取反\"运算。运算规则：~1=-2; ~0=-1; (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。 A >> 二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。 A >> 2 将得到 15，即为 0000 1111 #include int main() { unsigned int a = 60; /* 60 = 0011 1100 */ unsigned int b = 13; /* 13 = 0000 1101 */ int c = 0; c = a & b; /* 12 = 0000 1100 */ printf(\"Line 1 - c 的值是 %d\\n\", c ); c = a | b; /* 61 = 0011 1101 */ printf(\"Line 2 - c 的值是 %d\\n\", c ); c = a ^ b; /* 49 = 0011 0001 */ printf(\"Line 3 - c 的值是 %d\\n\", c ); c = ~a; /*-61 = 1100 0011 */ printf(\"Line 4 - c 的值是 %d\\n\", c ); c = a > 2; /* 15 = 0000 1111 */ printf(\"Line 6 - c 的值是 %d\\n\", c ); } /*运行结果为 Line 1 - c 的值是 12 Line 2 - c 的值是 61 Line 3 - c 的值是 49 Line 4 - c 的值是 -61 Line 5 - c 的值是 240 Line 6 - c 的值是 15 */ 赋值运算符 下表列出了 C 语言支持的赋值运算符： 运算符 描述 实例 = 简单的赋值运算符，把右边操作数的值赋给左边操作数 C = A + B 将把 A + B 的值赋给 C += 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 C += A 相当于 C = C + A -= 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 C -= A 相当于 C = C - A *= 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 C = A 相当于 C = C A /= 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 C /= A 相当于 C = C / A %= 求模且赋值运算符，求两个操作数的模赋值给左边操作数 C %= A 相当于 C = C % A 左移且赋值运算符 C >>= 右移且赋值运算符 C >>= 2 等同于 C = C >> 2 &= 按位与且赋值运算符 C &= 2 等同于 C = C & 2 ^= 按位异或且赋值运算符 C ^= 2 等同于 C = C ^ 2 \\ = 按位或且赋值运算符 C \\ = 2 等同于 C = C \\ 2 #include int main() { int a = 21; int c ; c = a; printf(\"Line 1 - = 运算符实例，c 的值 = %d\\n\", c ); c += a; printf(\"Line 2 - += 运算符实例，c 的值 = %d\\n\", c ); c -= a; printf(\"Line 3 - -= 运算符实例，c 的值 = %d\\n\", c ); c *= a; printf(\"Line 4 - *= 运算符实例，c 的值 = %d\\n\", c ); c /= a; printf(\"Line 5 - /= 运算符实例，c 的值 = %d\\n\", c ); c = 200; c %= a; printf(\"Line 6 - %%= 运算符实例，c 的值 = %d\\n\", c ); c >= 2; printf(\"Line 8 - >>= 运算符实例，c 的值 = %d\\n\", c ); c &= 2; printf(\"Line 9 - &= 运算符实例，c 的值 = %d\\n\", c ); c ^= 2; printf(\"Line 10 - ^= 运算符实例，c 的值 = %d\\n\", c ); c |= 2; printf(\"Line 11 - |= 运算符实例，c 的值 = %d\\n\", c ); } /*运行结果为 Line 1 - = 运算符实例，c 的值 = 21 Line 2 - += 运算符实例，c 的值 = 42 Line 3 - -= 运算符实例，c 的值 = 21 Line 4 - *= 运算符实例，c 的值 = 441 Line 5 - /= 运算符实例，c 的值 = 21 Line 6 - %= 运算符实例，c 的值 = 11 Line 7 - >= 运算符实例，c 的值 = 11 Line 9 - &= 运算符实例，c 的值 = 2 Line 10 - ^= 运算符实例，c 的值 = 0 Line 11 - |= 运算符实例，c 的值 = 2 */ 杂项运算符 ↦ sizeof & 三元 下表列出了 C 语言支持的其他一些重要的运算符，包括 sizeof 和 ? :。 运算符 描述 实例 sizeof() 返回变量的大小。 sizeof(a) 将返回 4，其中 a 是整数。 & 返回变量的地址。 &a; 将给出变量的实际地址。 * 指向一个变量。 *a; 将指向一个变量。 ? : 条件表达式 如果条件为真 ? 则值为 X : 否则值为 Y #include int main() { int a = 4; short b; double c; int* ptr; /* sizeof 运算符实例 */ printf(\"Line 1 - 变量 a 的大小 = %lu\\n\", sizeof(a) ); printf(\"Line 2 - 变量 b 的大小 = %lu\\n\", sizeof(b) ); printf(\"Line 3 - 变量 c 的大小 = %lu\\n\", sizeof(c) ); /* & 和 * 运算符实例 */ ptr = &a; /* 'ptr' 现在包含 'a' 的地址 */ printf(\"a 的值是 %d\\n\", a); printf(\"*ptr 是 %d\\n\", *ptr); /* 三元运算符实例 */ a = 10; b = (a == 1) ? 20: 30; printf( \"b 的值是 %d\\n\", b ); b = (a == 10) ? 20: 30; printf( \"b 的值是 %d\\n\", b ); } /*运行结果为 Line 1 - 变量 a 的大小 = 4 Line 2 - 变量 b 的大小 = 2 Line 3 - 变量 c 的大小 = 8 a 的值是 4 *ptr 是 4 b 的值是 30 b 的值是 20 */ C 中的运算符优先级 运算符的优先级确定表达式中项的组合。这会影响到一个表达式如何计算。某些运算符比其他运算符有更高的优先级，例如，乘除运算符具有比加减运算符更高的优先级。 下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。 类别 运算符 结合性 后缀 () [] -> . ++ - - 从左到右 一元 + - ! ~ ++ - - (type)* & sizeof 从右到左 乘除 * / % 从左到右 加减 + - 从左到右 移位 > 从左到右 关系 >= 从左到右 相等 == != 从左到右 位与 AND & 从左到右 位异或 XOR ^ 从左到右 位或 OR \\ 从左到右 逻辑与 AND && 从左到右 逻辑或 OR \\ \\ 从左到右 条件 ?: 从右到左 赋值 = += -= *= /= %=>>= = 从右到左 逗号 , 从左到右 #include main() { int a = 20; int b = 10; int c = 15; int d = 5; int e; e = (a + b) * c / d; // ( 30 * 15 ) / 5 printf(\"(a + b) * c / d 的值是 %d\\n\", e ); e = ((a + b) * c) / d; // (30 * 15 ) / 5 printf(\"((a + b) * c) / d 的值是 %d\\n\" , e ); e = (a + b) * (c / d); // (30) * (15/5) printf(\"(a + b) * (c / d) 的值是 %d\\n\", e ); e = a + (b * c) / d; // 20 + (150/5) printf(\"a + (b * c) / d 的值是 %d\\n\" , e ); return 0; } /*运行结果： (a + b) * c / d 的值是 90 ((a + b) * c) / d 的值是 90 (a + b) * (c / d) 的值是 90 a + (b * c) / d 的值是 50 */ 判断语句（与C#无异） C 语言提供了以下类型的判断语句。点击链接查看每个语句的细节。 语句 描述 if 语句 一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。 if...else 语句 一个 if 语句 后可跟一个可选的 else 语句，else 语句在布尔表达式为假时执行。 嵌套 if 语句 您可以在一个 if 或 else if 语句内使用另一个 if 或 else if 语句。 switch 语句 一个 switch 语句允许测试一个变量等于多个值时的情况。 嵌套 switch 语句 您可以在一个 switch 语句内使用另一个 switch 语句。 ? : 运算符(三元运算符) #include int main() { int num; printf(\"输入一个数字 : \"); scanf(\"%d\",&num); (num%2==0)?printf(\"偶数\"):printf(\"奇数\"); } C 循环(和C#没差别) 循环类型 循环类型 描述 while 循环 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。 for 循环 多次执行一个语句序列，简化管理循环变量的代码。 do...while 循环 除了它是在循环主体结尾测试条件外，其他与 while 语句类似。 嵌套循环 您可以在 while、for 或 do..while 循环内使用一个或多个循环。 循环控制语句 循环控制语句改变你代码的执行顺序。通过它你可以实现代码的跳转。 C 提供了下列的循环控制语句。点击链接查看每个语句的细节。 控制语句 描述 break 语句 终止循环或 switch 语句，程序流将继续执行紧接着循环或 switch 的下一条语句。 continue 语句 告诉一个循环体立刻停止本次循环迭代，重新开始下次循环迭代。 goto 语句 将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。 无限循环 如果条件永远不为假，则循环将变成无限循环。for 循环在传统意义上可用于实现无限循环。由于构成循环的三个表达式中任何一个都不是必需的，您可以将某些条件表达式留空来构成一个无限循环。 #include int main () { for( ; ; ) { printf(\"该循环会永远执行下去！\\n\"); } return 0; } //当条件表达式不存在时，它被假设为真。您也可以设置一个初始值和增量表达式，但是一般情况下，C 程序员偏向于使用 for(;;) 结构来表示一个无限循环。 © luckly FED Team all right reserved，powered by Gitbook该文件修订时间： 2022-09-16 15:44:26 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/b.html":{"url":"Chapter1/b.html","title":"函数，函数指针与回调函数","keywords":"","body":"C 函数 函数是一组一起执行一个任务的语句。每个 C 程序都至少有一个函数，即主函数 main() ，所有简单的程序都可以定义其他额外的函数。 您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。 函数声明告诉编译器函数的名称、返回类型和参数。函数定义提供了函数的实际主体。 C 标准库提供了大量的程序可以调用的内置函数。例如，函数 strcat() 用来连接两个字符串，函数 memcpy() 用来复制内存到另一个位置。 定义函数 C 语言中的函数定义的一般形式如下： return_type function_name( parameter list ) { body of the function } 在 C 语言中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分： 返回类型：一个函数可以返回一个值。return_type 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 void。 函数名称：这是函数的实际名称。函数名和参数列表一起构成了函数签名。 参数：参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。 函数主体：函数主体包含一组定义函数执行任务的语句。 函数声明 int max(int num1, int num2) { /* 局部变量声明 */ int result; if (num1 > num2) { result = num1; } else { result = num2; } return result; } 函数声明会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。 函数声明包括以下几个部分： return_type function_name( parameter list ); 针对上面定义的函数 max()，以下是函数声明： int max(int num1, int num2); 在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明： int max(int, int); 当在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，应该在调用函数的文件顶部声明函数 调用函数 创建 C 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。 当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。 调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。例如： #include /* 函数声明 */ int max(int num1, int num2); int main () { /* 局部变量定义 */ int a = 100; int b = 200; int ret; /* 调用函数来获取最大值 */ ret = max(a, b); printf( \"Max value is : %d\\n\", ret ); return 0; } /* 函数返回两个数中较大的那个数 */ int max(int num1, int num2) { /* 局部变量声明 */ int result; if (num1 > num2) result = num1; else result = num2; return result; } /*运行结果为 Max value is : 200 */ 函数参数 如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的形式参数。 形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。 当调用函数时，有两种向函数传递参数的方式： 调用类型 描述 传值调用 该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。 引用调用 通过指针传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。 默认情况下，C 使用传值调用来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的实际参数。 函数指针（建议先学习什么是指针） 函数指针是指向函数的指针变量。 通常我们说的指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数。 函数指针可以像一般函数一样，用于调用函数、传递参数。 函数指针变量的声明： typedef int (*fun_ptr)(int,int); // 声明一个指向同样参数、返回值的函数指针类型 #include int max(int x, int y) { return x > y ? x : y; } int main(void) { /* p 是函数指针 */ int (* p)(int, int) = & max; // &可以省略 int a, b, c, d; printf(\"请输入三个数字:\"); scanf(\"%d %d %d\", & a, & b, & c); /* 与直接调用函数等价，d = max(max(a, b), c) */ d = p(p(a, b), c); printf(\"最大的数字是: %d\\n\", d); return 0; } /*运行结果 请输入三个数字:1 2 3 最大的数字是: 3 */ 回调函数 函数指针作为某个函数的参数 函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。 简单讲：回调函数是由别人的函数执行时调用你实现的函数。 以下是来自知乎作者常溪玲的解说： 你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。 实例 实例中 populate_array() 函数定义了三个参数，其中第三个参数是函数的指针，通过该函数来设置数组的值。 实例中我们定义了回调函数 getNextRandomValue()，它返回一个随机值，它作为一个函数指针传递给 populate_array() 函数。 populate_array() 将调用 10 次回调函数，并将回调函数的返回值赋值给数组。 #include #include void populate_array(int *array, size_t arraySize, int (*getNextValue)(void)) { for (size_t i=0; i 运行结果： 16807 282475249 1622650073 984943658 1144108930 470211272 101027544 1457850878 1458777923 2007237709 © luckly FED Team all right reserved，powered by Gitbook该文件修订时间： 2022-09-16 16:07:16 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/c.html":{"url":"Chapter1/c.html","title":"指针","keywords":"","body":"C 指针 通过指针，可以简化一些 C 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。每一个变量都有一个内存位置，每一个内存位置都定义了可使用 & 运算符访问的地址，它表示了在内存中的一个地址。 #include int main () { int var_runoob = 10; int *p; // 定义指针变量 p = &var_runoob; printf(\"var_runoob 变量的地址： %p\\n\", p); return 0; } /*运行结果为 var_runoob 变量的地址： 0x7ffeeaae08d8（输出结果不一定回一摸一样，因为每个系统的不一样） */ © luckly FED Team all right reserved，powered by Gitbook该文件修订时间： 2022-09-19 09:42:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter1/d.html":{"url":"Chapter1/d.html","title":"学习笔记","keywords":"","body":"学习笔记 我的第一个C程序 实例 #include int main() { /* 我的第一个 C 程序 */ printf(\"Hello, World! \\n\"); return 0; } 解析： 所有的 C 语言程序都需要包含 main() 函数。 代码从 main() 函数开始执行。 /* ... */ 用于注释说明。 printf() 用于格式化输出到屏幕。printf() 函数在 \"stdio.h\" 头文件中声明。 stdio.h 是一个头文件 (标准输入输出头文件) , #include 是一个预处理命令，用来引入头文件。 当编译器遇到 printf() 函数时，如果没有找到 stdio.h 头文件，会发生编译错误。 return 0; 语句用于表示退出程序。 © luckly FED Team all right reserved，powered by Gitbook该文件修订时间： 2022-09-15 15:15:14 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter2/d.html":{"url":"Chapter2/d.html","title":"都江堰操作系统","keywords":"","body":"都江堰操作系统 © luckly FED Team all right reserved，powered by Gitbook该文件修订时间： 2022-10-31 17:02:21 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter2/a.html":{"url":"Chapter2/a.html","title":"宠物","keywords":"","body":"宠物 *从主程序入手（忽略蓝牙功能） ptu32_t djy_main(void) { #if 0 //测试蓝牙 int ble_test(); ble_test(); while (1) { DJY_EventDelay(2000*1000); } #endif s32 j; LP_BSP_ResigerGpioToWakeUpL4(PS_DEEP_WAKEUP_GPIO,13,1,0); /* //----------------------------------------------------------------------------- //功能：设置从深度睡眠中唤醒条件，设置的条件可以叠加 //参数：way, 唤醒信源，可选择：PS_DEEP_WAKEUP_GPIO、PS_DEEP_WAKEUP_RTC、PS_DEEP_WAKEUP_GPIO_RTC // gpio_index，如果way == PS_DEEP_WAKEUP_GPIO，指定gpio编号，0~39代表P0~P39 // 要设置多个引脚，可多次调用本函数，way 等于其他值本参数无效。 // gpio_edge，唤醒边沿，0 = 上升沿，1 = 下降沿，way == PS_DEEP_WAKEUP_GPIO才有效 // time，如果way == PS_DEEP_WAKEUP_RTC，用于表示休眠时间，单位 = ？ //返回：无 //----------------------------------------------------------------------------- void LP_BSP_ResigerGpioToWakeUpL4(PS_DEEP_WAKEUP_WAY way,u32 gpio_index, u32 gpio_edge, u32 time) { u32 map; deep_sleep_param.wake_up_way = way; if(way == PS_DEEP_WAKEUP_GPIO) { if(gpio_index © luckly FED Team all right reserved，powered by Gitbook该文件修订时间： 2022-10-29 18:34:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter2/b.html":{"url":"Chapter2/b.html","title":"遇到函数问题问题（这里的函数为C语言库中的函数）","keywords":"","body":"遇到函数问题问题（这里的函数为C语言库中的函数） os_memset 描述 C 库函数 void *memset(void *str, int c, size_t n) 复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。 声明 下面是 memset() 函数的声明。 void *memset(void *str, int c, size_t n) 参数 str -- 指向要填充的内存块。 c -- 要被设置的值。该值以 int 形式传递，但是函数在填充内存块时是使用该值的无符号字符形式。 n -- 要被设置为该值的字符数。 返回值 该值返回一个指向存储区 str 的指针。 #include #include int main () { char str[50]; strcpy(str,\"This is string.h library function\"); puts(str); memset(str,'$',7); puts(str); return(0); /*运行结果 This is string.h library function $$$$$$$ string.h library function */ © luckly FED Team all right reserved，powered by Gitbook该文件修订时间： 2022-09-21 16:18:06 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter3/b.html":{"url":"Chapter3/b.html","title":"宠物开发","keywords":"","body":"宠物开发 © luckly FED Team all right reserved，powered by Gitbook该文件修订时间： 2022-10-31 17:02:21 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter3/a.html":{"url":"Chapter3/a.html","title":"宠物","keywords":"","body":"宠物 © luckly FED Team all right reserved，powered by Gitbook该文件修订时间： 2022-10-31 16:57:28 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter4/c.html":{"url":"Chapter4/c.html","title":"一些好用的网站","keywords":"","body":"一些好用的网站 这个比什么都没留下...................................... © luckly FED Team all right reserved，powered by Gitbook该文件修订时间： 2022-11-23 11:41:04 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter4/a.html":{"url":"Chapter4/a.html","title":"学习网站","keywords":"","body":"学习网站 乘风导航 (一款还行的集成网站) w3cschool官网 - 编程狮，随时随地学编程 技术文档 | Microsoft Learn（微软官网） Python、JavaScript、Java、Git 等 (不咋好用) Stack Overflow 中文网 牛客网 中国大学MOOC(慕课)_国家精品课程在线学习平台 菜鸟教程 码谱 简书（能用但是不多） 博客园 - 开发者的网上家园 GitHub（有就借鉴咱这是借鉴可不是抄） C语言中文网：C语言程序设计门户网站(入门教程、编程软件) © luckly FED Team all right reserved，powered by Gitbook该文件修订时间： 2022-11-23 15:31:03 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter4/b.html":{"url":"Chapter4/b.html","title":"工具网站","keywords":"","body":"工具网站 Get Ubuntu | Download | Ubuntu（乌帮图） 二进制转十进制| 2进制转10进制 | 在线进制转换 (功能很多) 文本到图像生成器 - 免费工具 Index of /download/release/v10.22.0/ (可以下在旧版的node) 文字比较-在线和免费 在线PDF转Word_在线PDF转换成Word转换器_PDF在线转换|www.pdf365.cn 在线二维码图片生成器二维码扫描软件下载联图二维码 浏览器家园(中毒就不关我事了) 老毛桃winpe,u盘启动盘制作工具,u盘重装系统,老毛桃winpe下载 兔八哥极品软件园 © luckly FED Team all right reserved，powered by Gitbook该文件修订时间： 2022-11-23 14:25:12 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter4/d.html":{"url":"Chapter4/d.html","title":"感兴趣可以凑凑","keywords":"","body":"感兴趣可以凑凑 © luckly FED Team all right reserved，powered by Gitbook该文件修订时间： 2022-11-23 14:29:55 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Chapter5/a.html":{"url":"Chapter5/a.html","title":"问题解决","keywords":"","body":"问题解决 © luckly FED Team all right reserved，powered by Gitbook该文件修订时间： 2022-11-23 14:34:00 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"}}